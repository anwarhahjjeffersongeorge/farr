<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"main.js.html":{"id":"main.js.html","title":"Source: main.js","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation Source: main.js 'use strict' import kindOf from 'kind-of' import dayjs from 'dayjs' import temporal from 'temporal' const MAX_ARRAY_INDEX = 2 ** 32 - 1 const MIN_NEGA_INDEX = -(MAX_ARRAY_INDEX + 1) /** * @classdesc * @augments Array * arrays of __functions only__ */ class Farr extends Array { /** * after - schedule the next terminal command to occur after __t__ milliseconds * - chainable * @method * @memberof Farr# * @name after * @param {(String|Number)} [t] the millisecond delay after which the next terminal command should occur...if a non-Number object is provided, it will be cast to Number * @return {Farr} this instance (Proxy) * @tutorial after */ #after = (t) =&gt; { if (['string'].includes(kindOf(t))) { t = Number(t) } // console.log(t) if (typeof t === 'number') { this.#commands.t0 = () =&gt; { return (t &gt; 0) ? t : Farr.baseCommands.t0 } } return this.#returnP() } /** * a function that produces a function returning the argument provided to the first function. Override it in a subclass to change the function-making behavior of instances. * * By default, it returns * - Function-type arguments unchanged, and * - Non-function-type arguments wrapped in functions. * @method * @memberof Farr# * @name funcWrapper * @param {(object)} [v] anything * @return {function} */ funcWrapper = v =&gt; typeof v === 'function' ? v : () =&gt; v /** * at - schedule the next terminal command to occur at date/time __t__ * - chainable * @method * @memberof Farr# * @name at * @param {(String|Number|date|dayjs)} [t] the date/time at which the next terminal command should occur...if a non-dayjs object is provided, it will be cast to dayjs * @return {Farr} this instance (Proxy) * @tutorial at */ #at = (t) =&gt; { if (['string', 'number', 'date'].includes(kindOf(t))) { t = dayjs(t) } if (t instanceof dayjs) { this.#commands.t0 = () =&gt; { const now = dayjs() return (t.isAfter(now)) ? t - dayjs() : Farr.baseCommands.t0 } } // console.log(this.#commands); return this.#returnP() } // the current commands for the next terminal function call #commands = Object.assign({}, Farr.baseCommands) /** * get this.#commands as a JSON object] * * @method * @memberof Farr# * @name commandJson */ #commandJson = () =&gt; { const o = Object.assign({}, this.#commands) for (let k in o) { if (o.hasOwnProperty(k)) { o[k] = (typeof o[k] === 'function') ? o[k]() : o[k] } return JSON.stringify(o) } } // constrain a given array index #constrainIndex = i =&gt; (Math.sign(i) === -1) ? this.length + Number(i) : i /** * reset the current this.#commands * * @method * @memberof Farr# * @name clearCommands */ #clearCommands = () =&gt; { Object.assign(this.#commands, Farr.baseCommands) } /** * halt current activities, including * 1. temporal tasks, and * 2. any timers * * @method * @memberof Farr# * @name halt */ #halt = () =&gt; { temporal.stop() this.#timerPool.forEach(timer =&gt; clearTimeout(timer)) } // controls to be exposed #controls = new Map([ ['clearCommands', this.#clearCommands.bind(this)], ['commandJson', this.#commandJson.bind(this)], ['halt', this.#halt.bind(this)] ]) /** * nCycles - schedule the next terminal command to occur __n__ times * - chainable * @method * @memberof Farr# * @name nCycles * @param {Number} [n=1] the number of times the next terminal command should occur... * @return {Farr} this instance (Proxy) * @tutorial nCycles */ #nCycles = (n) =&gt; { n = (kindOf(n) === 'number') ? n : 1 this.#commands.nCycles = n return this.#returnP() } // keys for parsing non terminal (chainable) commands #nonterminals = new Map([ ['after', this.#after], ['at', this.#at], ['nCycles', this.#nCycles] ]) // a Proxy to this #P = null // get the Proxy to be returned by nonterminal functions #returnP = () =&gt; this.#P // keys for parsing terminal commands #terminals = new Map([ ['all', this.all], ['cascade', this.cascade], ['periodic', this.periodic] ]) // the timers created by this instance #timerPool = new Set() // get a task-wrapped function corresponding to those in this.#terminals #wrappedTerminal = (terminal) =&gt; { const { t0, nCycles } = this.#commands const clearCommands = this.#clearCommands const dt = (typeof t0 === 'function') ? t0() : null const f = terminal.bind(this) return async (arg) =&gt; { clearCommands() const cycle = async () =&gt; { // const C = new Array(nCycles).fill(f.bind(this)) let s = arg for (let i = 0; i &lt; nCycles; i++) { if (i === 0) { s = (s) ? await f(s) : await f() } else { s = await f({ s }) } } return s } return (dt) ? new Promise((resolve) =&gt; { const timeout = setTimeout(() =&gt; { // console.log(`@t${bigint()}, timeout`) resolve(cycle(timeout)) clearTimeout(timeout) this.#timerPool.delete(timeout) }, dt) this.#timerPool.add(timeout) // console.log(`@t${bigint()}, timeout`) }) : Promise.resolve(cycle()) } } /** * constructor - create a Farr instance * * @param {(Array|number)} [arr] if an Array, its elements will be used to populate the new instance. if a number, it sets the instance's length -- Array * @return {Array} this instance (Proxy) * @tutorial constructor */ constructor (arr) { super() this.#P = new Proxy(this, { set (target, prop, value) { if (Farr.isSafeIndex(prop)) { prop = target.#constrainIndex(prop) return Reflect.set(target, prop, target.funcWrapper(value)) } return Reflect.set(...arguments) }, get (target, prop, receiver) { if (Farr.isSafeIndex(prop)) { prop = target.#constrainIndex(prop) } else if (kindOf(prop) === 'string') { if (target.#nonterminals.has(prop)) { return (...args) =&gt; target.#nonterminals.get(prop)(...args) } else if (target.#terminals.has(prop)) { const terminal = target.#terminals.get(prop) return target.#wrappedTerminal(terminal) } else if (target.#controls.has(prop)) { return target.#controls.get(prop) } } return Reflect.get(target, prop, receiver) } }) if (Array.isArray(arr)) { this.#P.push(...arr) } else if (Number.isInteger(arr)) { this.length = arr } return this.#returnP() } /** * async all - A unary asynchronous instance method that * - calls functions in order, * - resolves when all the functions called return, and * - accepts a parameter __arg__ that contains * 1. a starting value __arg.s__ to be passed to all functions * - * @async * @param {object} [arg = {s: undefined}] argument * @return {Promise} result of Promise.all call on this' function elements * @tutorial all */ async all (arg = { s: undefined }) { let { s } = arg const getS = (i) =&gt; (Array.isArray(s) &amp;&amp; s.length &gt;= this.length) ? s[i] : s return Promise.all(this.map((f, i) =&gt; f(getS(i)))) } /** * async cascade - A unary asynchronous instance method that * - calls functions in order, * - accepts a parameter __arg__ that contains * 1. a starting value __arg.s__ to be passed to the first function * - mutates the given start value * @async * @param {object} [arg = {s: undefined}] argument * @return {Promise} result of Promise.all call on this' function elements * @tutorial cascade */ async cascade (arg = { s: undefined }) { let { s } = arg for await (let f of this) { s = await f(s) } return s } /** * get head - get the first element * * @return {function} the 0th element */ get head () { return this[0] } /** * async periodic - A unary asynchronous instance method that * - calls functions in order, * - accepts a parameter __arg__ that contains * 1. a starting value __arg.s__ to be passed to all functions * 2. a millisecond interval value __arg.delay__ * * @async * @param {object} [arg = {delay: 233, s: undefined}] argument * @return {Promise} eventual result of call on this' function elements * @tutorial periodic */ async periodic (arg = { delay: 233, s: undefined }) { const { s, delay } = arg const { length } = this const results = new Array(length) const tasks = new Array(length) for (let i = 0; i &lt; length; i++) { const f = this[i] tasks[i] = { delay, task: () =&gt; { results[i] = Promise.resolve(f(s)) .catch(err =&gt; err) } } } // console.log(tasks) // const queue = await this.temporal.queue(tasks) await this.temporal.queue(tasks) // console.log(queue) return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(Promise.all(results)), delay * length) }) } /** * get tail - get the last element * * @return {function} the last element */ get tail () { return this[-1] } /** * get temporal - get the temporal instance used by this instance * * @return {object} the temporal instance */ get temporal () { return temporal } } Object.defineProperties(Farr, { /** * the default commands * @memberof Farr * @name baseCommands * @static */ baseCommands: { value: Object.freeze({ t0: 0, nCycles: 1 }), enumerable: true, writable: false, configurable: false }, /** * determine whether a number __d__ can be used as an array index * @method * @name isSafeIndex * @param {Number} d the number to test * @return {Boolean} true if d is a usable array index * @memberof Farr * @static */ isSafeIndex: { value: (d) =&gt; { return (typeof d !== 'symbol') &amp;&amp; Number.isInteger(+d) &amp;&amp; MIN_NEGA_INDEX &lt;= d &amp;&amp; d &lt;= MAX_ARRAY_INDEX }, enumerable: true, writable: false, configurable: false }, /** * array containing the string keys of the non terminal functions * * @name nonTerminalKeys * @memberof Farr * @static */ nonTerminalKeys: { value: [ 'after', 'at', 'nCycles' ], enumerable: true, writable: false, configurable: false } }) export { Farr } Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation Classes Classes Farr Ã— Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation Tutorials Classes Farr Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation â€” farr â€” Documentation arrays of functions only This module exports a single class Farr, that extends the native Array class. Anytime an array-index-valued property of a Farr is set, the provided value gets filtered: If the value is a function, it's left as-is. If the value is not a function, it's replaced by a new anonymous function that produces the value when called. This means thatFarr arrays only store function elements or empty slots. Methods Farr instances have various methods. Terminal Methods These are unary, asynchronous and non-chainable: .all .cascade .periodic Nonterminal Methods These are variadic, synchronous and chainable: .at .after .nCycles Installation Run npm install farr Usage import {Farr} from 'farr' or const Farr = require('farr') Testing Run npm test Documentation Please see Docs. Contributing Guidelines All tests must pass. Code must adhere to JavaScript Standard Style. New code must include JSDoc documentation. Build must pass TravisCI. Thanks. License Unlicense Author Anwar Hahj Jefferson-George Ã— Search results Close "},"Farr.html":{"id":"Farr.html","title":"Class: Farr","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation Class: Farr Farr new Farr( [arr]) constructor - create a Farr instance Parameters: Name Type Argument Description arr Array | number &lt;optional&gt; if an Array, its elements will be used to populate the new instance. if a number, it sets the instance's length -- Array Source: main.js, line 195 Tutorials: new Farr() Returns: this instance (Proxy) Type Array Extends Array Members &lt;static&gt; baseCommands the default commands Source: main.js, line 333 &lt;static&gt; nonTerminalKeys array containing the string keys of the non terminal functions Source: main.js, line 365 head get head - get the first element Source: main.js, line 272 tail get tail - get the last element Source: main.js, line 318 temporal get temporal - get the temporal instance used by this instance Source: main.js, line 327 Methods &lt;static&gt; isSafeIndex(d) determine whether a number d can be used as an array index Parameters: Name Type Description d Number the number to test Source: main.js, line 348 Returns: true if d is a usable array index Type Boolean after( [t]) after - schedule the next terminal command to occur after t milliseconds chainable Parameters: Name Type Argument Description t String | Number &lt;optional&gt; the millisecond delay after which the next terminal command should occur...if a non-Number object is provided, it will be cast to Number Source: main.js, line 13 Tutorials: .after Returns: this instance (Proxy) Type Farr &lt;async&gt; all( [arg]) async all - A unary asynchronous instance method that calls functions in order, resolves when all the functions called return, and accepts a parameter arg that contains a starting value arg.s to be passed to all functions Parameters: Name Type Argument Default Description arg object &lt;optional&gt; {s: undefined} argument Source: main.js, line 242 Tutorials: .all Returns: result of Promise.all call on this' function elements Type Promise at( [t]) at - schedule the next terminal command to occur at date/time t chainable Parameters: Name Type Argument Description t String | Number | date | dayjs &lt;optional&gt; the date/time at which the next terminal command should occur...if a non-dayjs object is provided, it will be cast to dayjs Source: main.js, line 50 Tutorials: .at Returns: this instance (Proxy) Type Farr &lt;async&gt; cascade( [arg]) async cascade - A unary asynchronous instance method that calls functions in order, accepts a parameter arg that contains a starting value arg.s to be passed to the first function mutates the given start value Parameters: Name Type Argument Default Description arg object &lt;optional&gt; {s: undefined} argument Source: main.js, line 259 Tutorials: .cascade Returns: result of Promise.all call on this' function elements Type Promise clearCommands() reset the current this.#commands Source: main.js, line 93 commandJson() get this.#commands as a JSON object] Source: main.js, line 75 funcWrapper( [v]) a function that produces a function returning the argument provided to the first function. Override it in a subclass to change the function-making behavior of instances. By default, it returns Function-type arguments unchanged, and Non-function-type arguments wrapped in functions. Parameters: Name Type Argument Description v object &lt;optional&gt; anything Source: main.js, line 37 Returns: Type function halt() halt current activities, including temporal tasks, and any timers Source: main.js, line 103 nCycles( [n]) nCycles - schedule the next terminal command to occur n times chainable Parameters: Name Type Argument Default Description n Number &lt;optional&gt; 1 the number of times the next terminal command should occur... Source: main.js, line 122 Tutorials: .nCycles Returns: this instance (Proxy) Type Farr &lt;async&gt; periodic( [arg]) async periodic - A unary asynchronous instance method that calls functions in order, accepts a parameter arg that contains a starting value arg.s to be passed to all functions a millisecond interval value arg.delay Parameters: Name Type Argument Default Description arg object &lt;optional&gt; {delay: 233, s: undefined} argument Source: main.js, line 288 Tutorials: .periodic Returns: eventual result of call on this' function elements Type Promise Ã— Search results Close "},"tutorial-after.html":{"id":"tutorial-after.html","title":"Tutorial: .after","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation .after Scheduling a call to follow a delay Perform the next terminal call after a specified wait period: (async () =&gt; { const delay = 1600 // milliseconds, number or numeric string const numFs = 16 let fs = Array(numFs).fill((a = 0) =&gt; { return a-1 }) const f = new Farr(fs) f.after(delay) const result = await f.cascade() // -16 ... about 1600 ms later })() Perform the above with chaining: (async () =&gt; { const delay = 1600 // milliseconds const numFs = 16 let fs = Array(numFs).fill((a = 0) =&gt; { return a-1 }) const f = new Farr(fs) const result = await f.after(delay).cascade() // -16 ... about 1600 ms later })() Accuracy Calling .after erases any previous command set by calling .after or .at. Timing is not guaranteed to be exact and starts from roughly the moment of the next terminal call. Reference setTimeout Ã— Search results Close "},"tutorial-all.html":{"id":"tutorial-all.html","title":"Tutorial: .all","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation .all \"Not-quite Parallel\" calls Call all of the functions in the array, awaiting the resolution of all (async () =&gt; { const n = 10 const fs = [] for (let i = 0; i &lt; n; i++) { fs[i] = (d = '') =&gt; d.toString() + i.toString() } const f = new Farr(fs) const result= await f.all() // [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] })() Perform the above, but do so with a start value (async () =&gt; { const n = 10 const fs = [] for (let i = 0; i &lt; n; i++) { fs[i] = (d = '') =&gt; d.toString() + i.toString() } const f = new Farr(fs) const result= await f.all('oooo') // ['oooo0', 'oooo1', 'oooo2','oooo3','oooo4','oooo5' 'oooo6', 'oooo7', 'oooo8', 'oooo9'] })() The calls performed in the Farr#all loop are not performed in true parallel. They are synchronous, and the function returns a valueasynchronously. For instance: new Farr(new Array(9).fill(process.hrtime.bigint)).all().then(console.log) // [ // 2647620485651672n, // 2647620485680829n, // 2647620485692420n, // 2647620485694427n, // 2647620485695742n, // 2647620485698066n, // 2647620485699393n, // 2647620485700595n, // 2647620485701760n // ] Reference Promise.all Ã— Search results Close "},"tutorial-at.html":{"id":"tutorial-at.html","title":"Tutorial: .at","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation .at Scheduling a call to happen in the future Perform the next terminal call at a specified date/time: (async () =&gt; { const datetime = dayjs().add(1, 'day') // dayjs instance, but can be dayjs-parseable date string const numFs = 16 let fs = Array(numFs).fill((a = 0) =&gt; { return a-1 }) const f = new Farr(fs) f.at(datetime) const result = await f.cascade() // -16... about a day later })() Perform the above with chaining: (async () =&gt; { cconst datetime = dayjs().add(1, 'day') // dayjs instance, but can be dayjs-parseable date string const numFs = 16 let fs = Array(numFs).fill((a = 0) =&gt; { return a-1 }) const f = new Farr(fs) const result = await f.at(datetime).cascade() // -16 ... about a day later })() Accuracy Calling .at erases any previous command set by calling .at or .after. Timing is not guaranteed to be exact and starts from roughly the moment of the next terminal call. Reference setTimeout dayjs Ã— Search results Close "},"tutorial-cascade.html":{"id":"tutorial-cascade.html","title":"Tutorial: .cascade","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation .cascade Chaining calls Call all of the functions in the array, passing the result of each call to the next, awaiting the resolution of the last call (async () =&gt; { const n = 10 const fs = [] for (let i = 0; i &lt; n; i++) { fs[i] = (d = '') =&gt; d.toString() + i.toString() } const f = new Farr(fs) const result= await f.cascade() // '0123456789' })() Perform the above, but do so with a start value (async () =&gt; { const n = 10 const fs = [] for (let i = 0; i &lt; n; i++) { fs[i] = (d = '') =&gt; d.toString() + i.toString() } const f = new Farr(fs) const result= await f.cascade('o') // 'o0123456789' })() Ã— Search results Close "},"tutorial-constructor.html":{"id":"tutorial-constructor.html","title":"Tutorial: new Farr()","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation new Farr() Constructor Create a new instance: new Farr() Create a new instance from an array, transforming the elements into functions const types = ['283a', 33, {}, [], new Int16Array(), null] const f = new Farr(types) f // Farr @Array [ Function {}, Function {}, Function {}, Function {}, Function {}, Function {} ] f[0]() // '283a' Ã— Search results Close "},"tutorial-index_.html":{"id":"tutorial-index_.html","title":"Tutorial: index","body":" Documentation Classes Farr Tutorials .all.cascadenew Farr().periodicInstallation farr 0.0.2 farr arrays of functions only This module exports a single class Farrthat extends the native Array class. Anytime an integer-valued property of a Farr is set, the provided value gets filtered: If the value is a function, it's left as-is. If the value is not a function, it's replaced by a new anonymous function that produces the value when called. Thus, Farr arrays only store function elements. Installation Run npm install farr Usage import {Farr} from 'farr' or const Farr = require('farr') Testing Run npm test Ã— Search results Close "},"tutorial-nCycles.html":{"id":"tutorial-nCycles.html","title":"Tutorial: .nCycles","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation .nCycles Doing cycles of calls Repeat the next terminal call a given number of cycles, passing the result of one cycle to the next: (async () =&gt; { const nCycles = 16 const numFs = 16 let fs = Array(numFs).fill((a = 0) =&gt; { return a-1 }) const f = new Farr(fs) f.nCycles(nCycles) const result = await f.cascade() // -256 === -16 * 16 })() Perform the above, but do so with a start value (async () =&gt; { const nCycles = 16 const numFs = 16 let fs = Array(numFs).fill((a = 0) =&gt; { return a-1 }) const f = new Farr(fs) f.nCycles(nCycles) const result = await f.cascade({s: 1}) // -255 === 1 - (16 * 16) })() Reference temporal Ã— Search results Close "},"tutorial-periodic.html":{"id":"tutorial-periodic.html","title":"Tutorial: .periodic","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation .periodic Calling at fixed intervals Call all of the functions in the array with a specified delay between calls: (async () =&gt; { const n = 9 const fs = new Array(n).fill(() =&gt; Math.floor(Number(process.hrtime.bigint) / 1e6 )) const f = new Farr(fs) const result = await f.periodic({delay: 100}) // [ // 2648877237 // 2648877337 // 2648877437 // 2648877537 // 2648877637 // 2648877737 // 2648877837 // 2648877937 // 2648878037 // ] })() Perform the above, but do so with a start value: (async () =&gt; { const n = 9 const fs = new Array(n).fill(() =&gt; Math.floor(Number(process.hrtime.bigint) / 1e6 )) const f = new Farr(fs) const result = await f.periodic({delay: 100, s:'o'}) // [ // 'o2648877237' // 'o2648877337' // 'o2648877437' // 'o2648877537' // 'o2648877637' // 'o2648877737' // 'o2648877837' // 'o2648877937' // 'o2648878037' // ] })() Reference temporal Ã— Search results Close "},"tutorial-usage.html":{"id":"tutorial-usage.html","title":"Tutorial: Installation","body":" Documentation Classes Farr Tutorials .after.all.at.cascadenew Farr()index.nCycles.periodicInstallation Installation Installation npm install farr Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
